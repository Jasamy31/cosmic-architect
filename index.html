<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Architect</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            font-family: 'Inter', sans-serif;
            background-color: #0d0d0d; /* Dark background for space feel */
            color: #e0e0e0;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .info-panel {
            background-color: rgba(31, 41, 55, 0.7); /* bg-gray-800 with opacity */
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* shadow-lg */
            z-index: 10;
        }
        .game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0);
            padding: 2rem 3rem;
            border-radius: 10px;
            text-align: center;
            font-size: 2rem;
            font-weight: bold;
            color: #ffffff;
            z-index: 20;
            display: none; /* Hidden by default */
        }
        .game-button {
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            background-color: #4f46e5; /* indigo-600 */
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-right: 0.5rem;
            text-align: center;
            display: inline-block;
        }
        .game-button:hover {
            background-color: #4338ca; /* indigo-700 */
        }
        /* New classes for active button states */
        .game-button.active-place {
            background-color: #10b981; /* green-500 */
        }
        .game-button.active-remove {
            background-color: #ef4444; /* red-500 */
        }
        .control-panel {
            background-color: rgba(31, 41, 55, 0);
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            z-index: 10;
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen">
    <audio id="backgroundMusic" src="sounds/huge-vehicle-sound-76368.mp3" loop preload="auto" volume="1">
        Your browser does not support the audio element.
    </audio>

    <div class="volume-control">
        <span>Volume:</span>
        <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.2">
    </div>

    <div class="info-panel absolute top-4 left-4 max-w-xs md:max-w-md lg:max-w-lg">
        <h1 class="text-2xl font-bold mb-2 text-white">Cosmic Architect</h1>
        <p class="hidden md:block text-sm text-gray-300">
            Guide the formation of galaxies! Place or remove gravitational centers to attract
            particles and form stable cosmic structures.
            Use your mouse to orbit. Click a 'Place' or 'Remove' button, then click on the simulation.
        </p>
        <div class="mt-4 text-sm text-gray-400">
            <p><strong>Time Left:</strong> <span id="timeLeftValue"></span></p>
            <p><strong>Cosmic Energy (Moves):</strong> <span id="cosmicEnergyValue"></span></p>
            <p><strong>Galaxies Formed:</strong> <span id="galaxiesFormedCount">0</span> / <span id="targetGalaxiesNeeded"></span></p>
            <p><strong>Particles:</strong> <span id="particleCount"></span></p>
            <p><strong>Attractors:</strong> <span id="numGalaxiesValue"></span></p>
            <p><strong>Entropy:</strong> <span id="entropyValue"></span></p>
            <p><strong>Next Cosmic Event In:</strong> <span id="cosmicEventCountdownValue"></span>s</p>
            <p><strong>Last Cosmic Event:</strong> <span id="lastCosmicEventValue">None</span></p>
            <p><strong>Particles Obliterated:</strong> <span id="suckedParticleCount">0</span></p>
        </div>
    </div>

    <div id="gameControls" class="control-panel">
        <button id="placeGalaxyBtn" class="game-button">Place Attractor</button>
        <button id="removeGalaxyBtn" class="game-button">Remove Attractor</button>
    </div>

    <div id="canvas-container" class="w-full h-screen relative"></div>

    <div id="messageScreen" class="game-message">
        <p id="messageText"></p>
        <button id="restartGameBtn" class="game-button mt-4">Play Again</button>
    </div>

    <script>
        // Global variables for Three.js scene
        let scene, camera, renderer, controls;
        let particles; // Particle system
        let expansionSpeed = 0.05; // Controls how fast particles move outwards
        const initialNumParticles = 50000; // Initial number of particles in the simulation
        const maxParticleCapacity = 70000; // Max particles the buffer can hold (for white holes)
        let currentParticleCount = initialNumParticles; // Current number of active particles

        // Game State Variables
        let isGameActive = false;
        let isBigCrunchActive = false; // Flag for Big Crunch event
        let timeLeft = 180; // 3 minutes for the game (seconds)
        let gameTimerInterval;
        let entropyTimerInterval; // Timer for entropy updates

        let cosmicEnergy = 10; // Player's moves
        let energyRegenTimer;

        let galaxiesFormedCount = 0;
        let targetGalaxiesNeeded = 10; // Number of galaxies to form to win

        let gameMode = 'play'; // 'play', 'place', 'remove'

        // Galaxy Formation Parameters
        const galaxyFormationRadius = 20; // Radius around a proto-galaxy to count particles for formation
        const minParticlesForGalaxy = 750; // Number of particles needed to form a galaxy

        // Gravity parameters (from original simulator)
        const gravitationalConstant = 0.01;
        const softeningFactor = 5.0;

        // Speed of light constant (from original simulator)
        const speedOfLight = 2.0;

        // Galaxy clumping parameters (from original simulator)
        let numProtoGalaxies = 0; // Start with 0, player places them
        const protoGalaxyInitialSpread = 30; // Still used for initial random velocity boundaries
        const protoGalaxies = []; // Array to store the THREE.Group objects for proto-galaxies (each group holds a cross)
        const minGalaxyMass = 50;
        const maxGalaxyMassRand = 25;

        // Dynamic galaxy management parameters (for cosmic events)
        const minActiveGalaxies = 3; // Minimum number of proto-galaxies to keep active for events
        const maxActiveGalaxies = 16; // Maximum number of proto-galaxies allowed for events

        // Removal Ejection parameters (from original simulator)
        const removalEjectionRadius = 40;
        const removalForceMultiplier = 0.75;

        // Cosmic Event Parameters
        let cosmicEventInterval;
        let cosmicEventCountdown = 0; // Countdown for next event
        let cosmicEventTimer; // Timer for cosmic events

        // Black Hole Parameters
        const blackHoleSize = 5; // Visual size of the black hole
        const blackHoleSuckRadius = 15; // Radius within which particles are sucked
        const blackHoleDuration = 10; // How long a black hole stays active (seconds)
        const maxBlackHoles = 3; // Limit the number of active black holes
        const blackHoleMass = 1000; // Mass of the black hole
        const blackHoles = []; // Array to store active black hole objects
        let suckedParticleCount = 0; // Counter for particles sucked by black holes

        // Wormhole Parameters (NEW)
        const wormholeSize = 5; // Visual size of wormhole openings - INCREASED
        const funnelEntryMultiplier = 1.5; // How much wider the entry funnel is
        const funnelExitMultiplier = 0.1; // NEW: How much smaller the exit funnel is relative to wormholeSize (made smaller)
        const wormholeSuckRadius = 10; // Radius around entry where particles are sucked
        const wormholeSpitForce = 1.0; // Initial velocity applied when spit out - INCREASED
        const wormholeDuration = 15; // How long a wormhole stays active (seconds)
        const maxWormholes = 2; // Limit the number of active wormholes
        const minWormholeLength = 20; // Minimum length of the wormhole (made shorter)
        const maxWormholeLength = 60; // Maximum length of the wormhole (made shorter)
        const wormholes = []; // Array to store active wormhole objects

        // White Hole Parameters (NEW)
        const whiteHoleSize = 4; // Visual size of the white hole
        const whiteHoleEmitCount = 5000; // Number of particles emitted by a white hole
        const whiteHoleRepulsionForce = 0.15; // Force pushing particles away from white hole
        const whiteHoleDuration = 12; // How long a white hole stays active (seconds)
        const maxWhiteHoles = 2; // Limit the number of active white holes
        const whiteHoles = []; // Array to store active white hole objects

        // Raycaster for click interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // --- UI Elements ---
        const messageScreen = document.getElementById('messageScreen');
        const messageText = document.getElementById('messageText');
        const restartGameBtn = document.getElementById('restartGameBtn');
        const placeGalaxyBtn = document.getElementById('placeGalaxyBtn');
        const removeGalaxyBtn = document.getElementById('removeGalaxyBtn');
        const canvasContainer = document.getElementById('canvas-container');
        const lastCosmicEventValue = document.getElementById('lastCosmicEventValue');
        const suckedParticleCountElement = document.getElementById('suckedParticleCount');
        const particleCountElement = document.getElementById('particleCount');
        const gameControls = document.getElementById('gameControls'); // Get game controls div
        const entropyValueElement = document.getElementById('entropyValue'); // Entropy display element

        // Audio elements
        const backgroundMusic = document.getElementById('backgroundMusic');
        const volumeSlider = document.getElementById('volumeSlider');

        // --- Game Functions ---

        function startGame() {
            messageScreen.style.display = 'none';
            gameControls.style.display = 'flex'; // Ensure controls are visible

            // Attempt to play background music (will likely require user interaction)
            backgroundMusic.play().catch(error => {
                console.log("Autoplay prevented:", error);
                // Inform user to click somewhere to enable audio, if needed
            });

            // Re-initialize everything for a fresh game
            initThreeJSScene();
            createParticles();

            // Clear existing galaxies
            protoGalaxies.forEach(galaxy => scene.remove(galaxy));
            protoGalaxies.length = 0;

            // Clear existing black holes
            blackHoles.forEach(bh => scene.remove(bh.mesh));
            blackHoles.length = 0;
            suckedParticleCount = 0;

            // Clear existing wormholes
            wormholes.forEach(wh => {
                scene.remove(wh.group);
                if (wh.entryMesh.geometry) wh.entryMesh.geometry.dispose();
                if (wh.entryMesh.material) wh.entryMesh.material.dispose();
                if (wh.exitMesh.geometry) wh.exitMesh.geometry.dispose();
                if (wh.exitMesh.material) wh.exitMesh.material.dispose();
                if (wh.gridMesh.geometry) wh.gridMesh.geometry.dispose();
                if (wh.gridMesh.material) wh.gridMesh.material.dispose();
            });
            wormholes.length = 0;

            // Clear existing white holes
            whiteHoles.forEach(wh => {
                scene.remove(wh.mesh);
                if(wh.light) scene.remove(wh.light); // Remove the light source too
                if (wh.mesh.geometry) wh.mesh.geometry.dispose();
                if (wh.mesh.material) wh.mesh.material.dispose();
            });
            whiteHoles.length = 0;

            // Reset game state variables
            isGameActive = true;
            isBigCrunchActive = false; // Reset big crunch flag
            timeLeft = 180;
            cosmicEnergy = 10; // Initial finite moves
            galaxiesFormedCount = 0;
            gameMode = 'play';
            cosmicEventCountdown = getRandomCosmicEventInterval();
            lastCosmicEventValue.textContent = "None";
            currentParticleCount = initialNumParticles; // Reset current particle count

            // Update UI
            document.getElementById('timeLeftValue').textContent = timeLeft;
            document.getElementById('cosmicEnergyValue').textContent = cosmicEnergy;
            document.getElementById('galaxiesFormedCount').textContent = galaxiesFormedCount;
            document.getElementById('targetGalaxiesNeeded').textContent = targetGalaxiesNeeded;
            particleCountElement.textContent = currentParticleCount - suckedParticleCount;
            document.getElementById('numGalaxiesValue').textContent = protoGalaxies.length;
            document.getElementById('cosmicEventCountdownValue').textContent = cosmicEventCountdown;
            suckedParticleCountElement.textContent = suckedParticleCount;
            entropyValueElement.textContent = "Calculating..."; // Initial entropy text


            // Start timers/intervals
            if (gameTimerInterval) clearInterval(gameTimerInterval);
            gameTimerInterval = setInterval(updateGameTimer, 1000);

            if (energyRegenTimer) clearInterval(energyRegenTimer);

            if (cosmicEventTimer) clearInterval(cosmicEventTimer);
            cosmicEventTimer = setInterval(updateCosmicEventCountdown, 1000);

            if (entropyTimerInterval) clearInterval(entropyTimerInterval); // Clear any existing entropy timer
            entropyTimerInterval = setInterval(updateEntropyDisplay, 1000); // Start entropy timer

            // Ensure controls are enabled for orbiting
            controls.enabled = true;

            // Reset button states
            resetButtonStates();
            
            // Start animation loop if not already running
            if (!animationFrameId) {
                animate();
            }
        }

        function updateGameTimer() {
            if (!isGameActive) return;
            timeLeft--;
            document.getElementById('timeLeftValue').textContent = timeLeft;
            if (timeLeft <= 0) {
                triggerBigCrunch(); // Trigger Big Crunch
            }
        }

        function triggerBigCrunch() {
            isGameActive = false; // Stop all regular game logic
            isBigCrunchActive = true; // Activate Big Crunch mode
            clearInterval(gameTimerInterval);
            clearInterval(cosmicEventTimer);
            clearInterval(entropyTimerInterval); // Clear entropy timer during crunch
            gameControls.style.display = 'none'; // Hide controls during crunch
            messageScreen.style.display = 'flex'; // Show message screen
            messageText.textContent = "OUT OF TIME";
            restartGameBtn.style.display = 'none'; // Hide play again button temporarily

            // Remove all existing proto-galaxies, black holes, wormholes, and white holes from the scene
            protoGalaxies.forEach(galaxy => scene.remove(galaxy));
            protoGalaxies.length = 0;
            blackHoles.forEach(bh => scene.remove(bh.mesh));
            blackHoles.length = 0;
            wormholes.forEach(wh => {
                scene.remove(wh.group);
                if (wh.entryMesh.geometry) wh.entryMesh.geometry.dispose();
                if (wh.entryMesh.material) wh.entryMesh.material.dispose();
                if (wh.exitMesh.geometry) wh.exitMesh.geometry.dispose();
                if (wh.exitMesh.material) wh.exitMesh.material.dispose();
                if (wh.gridMesh.geometry) wh.gridMesh.geometry.dispose();
                if (wh.gridMesh.material) wh.gridMesh.material.dispose();
            });
            wormholes.length = 0;
            whiteHoles.forEach(wh => {
                scene.remove(wh.mesh);
                if(wh.light) scene.remove(wh.light);
                if (wh.mesh.geometry) wh.mesh.geometry.dispose();
                if (wh.mesh.material) wh.mesh.material.dispose();
            });
            whiteHoles.length = 0;

            // Set up a final delay before showing game over message
            setTimeout(() => {
                isBigCrunchActive = false; // Deactivate crunch mode
                endGame(false); // Now officially end the game and show restart button
            }, 10000); // 10 seconds for the crunch effect
        }

        function getRandomCosmicEventInterval() {
            return Math.floor(Math.random() * (25 - 15 + 1)) + 15;
        }

        function updateCosmicEventCountdown() {
            if (!isGameActive) return;
            cosmicEventCountdown--;
            document.getElementById('cosmicEventCountdownValue').textContent = cosmicEventCountdown;
            if (cosmicEventCountdown <= 0) {
                triggerCosmicEvent();
                cosmicEventCountdown = getRandomCosmicEventInterval();
            }
        }

        function triggerCosmicEvent() {
            const eventTypeRoll = Math.random();
            let action;

            if (eventTypeRoll < 0.2) {
                action = 'add';
            } else if (eventTypeRoll < 0.5) {
                action = 'remove';
            } else if (eventTypeRoll < 0.7) {
                action = 'blackhole';
            } else if (eventTypeRoll < 0.8) {
                action = 'wormhole';
            } else { 
                action = 'whitehole'; // NEW Whitehole event
            }

            const eventPosition = new THREE.Vector3(
                (Math.random() - 0.5) * protoGalaxyInitialSpread * 4,
                (Math.random() - 0.5) * protoGalaxyInitialSpread * 4,
                (Math.random() - 0.5) * protoGalaxyInitialSpread * 4
            );

            if (action === 'add' && protoGalaxies.length < maxActiveGalaxies) {
                placeProtoGalaxyAtPosition(eventPosition, true);
                lastCosmicEventValue.textContent = "New Attractor Appeared!";

            } else if (action === 'remove' && protoGalaxies.length > minActiveGalaxies) {
                const randomIndex = Math.floor(Math.random() * protoGalaxies.length);
                const galaxyToRemove = protoGalaxies[randomIndex];
                removeSpecificProtoGalaxy(galaxyToRemove, true);
                lastCosmicEventValue.textContent = "A Galaxy Vanished!";
                cosmicEnergy++;
                document.getElementById('cosmicEnergyValue').textContent = cosmicEnergy;

            } else if (action === 'blackhole' && blackHoles.length < maxBlackHoles) {
                const blackHoleMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.8 });
                const blackHoleGeometry = new THREE.SphereGeometry(blackHoleSize, 16, 16);
                const blackHoleMesh = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
                blackHoleMesh.position.copy(eventPosition);
                scene.add(blackHoleMesh);

                blackHoles.push({
                    mesh: blackHoleMesh,
                    spawnTime: Date.now(),
                    suckRadius: blackHoleSuckRadius,
                    mass: blackHoleMass
                });
                lastCosmicEventValue.textContent = "A Black Hole Formed!";
                console.log("Cosmic Event: Black hole formed!");
            } else if (action === 'wormhole' && wormholes.length < maxWormholes) {
                const entryPosition = new THREE.Vector3(
                    (Math.random() - 0.5) * protoGalaxyInitialSpread * 4,
                    (Math.random() - 0.5) * protoGalaxyInitialSpread * 4,
                    (Math.random() - 0.5) * protoGalaxyInitialSpread * 4
                );
                let exitPosition;
                let currentLength;
                do {
                    exitPosition = new THREE.Vector3(
                        (Math.random() - 0.5) * protoGalaxyInitialSpread * 4,
                        (Math.random() - 0.5) * protoGalaxyInitialSpread * 4,
                        (Math.random() - 0.5) * protoGalaxyInitialSpread * 4
                    );
                    currentLength = entryPosition.distanceTo(exitPosition);
                } while (currentLength < minWormholeLength || currentLength > maxWormholeLength);

                const wormholeVisuals = createWormholeVisuals(entryPosition, exitPosition);
                scene.add(wormholeVisuals.group);

                wormholes.push({
                    entryMesh: wormholeVisuals.entryMesh,
                    exitMesh: wormholeVisuals.exitMesh,
                    gridMesh: wormholeVisuals.gridMesh,
                    entryPosition: entryPosition,
                    exitPosition: exitPosition,
                    spawnTime: Date.now(),
                    suckRadius: wormholeSuckRadius,
                    spitForce: wormholeSpitForce,
                    duration: wormholeDuration,
                    group: wormholeVisuals.group
                });
                lastCosmicEventValue.textContent = "A Wormhole Opened!";
                console.log("Cosmic Event: Wormhole opened!");
            } else if (action === 'whitehole' && whiteHoles.length < maxWhiteHoles) { // NEW White hole event logic
                addWhiteHole(eventPosition);
                lastCosmicEventValue.textContent = "A White Hole Erupted!";
                console.log("Cosmic Event: White hole erupted!");
            }
            else {
                lastCosmicEventValue.textContent = "Cosmic Fluctuation";
            }
        }

        /**
         * Places a new proto-galaxy at a specified 3D position.
         * @param {THREE.Vector3} position The 3D coordinates where the galaxy will be placed.
         * @param {boolean} isEventSpawned True if this galaxy is spawned by a cosmic event, false otherwise.
         */
        function placeProtoGalaxyAtPosition(position, isEventSpawned = false) {
            const crossMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const protoGalaxyGroup = new THREE.Group();

            const galaxyMass = minGalaxyMass + Math.random() * maxGalaxyMassRand;
            protoGalaxyGroup.mass = galaxyMass;
            protoGalaxyGroup.isFormed = false;

            const sizeScale = galaxyMass / (minGalaxyMass + maxGalaxyMassRand);
            const crossArmLength = 2 * sizeScale;
            // Adjusted thickness for flatter appearance
            const crossArmThickness = 0.05 * sizeScale; 

            const horizontalArm = new THREE.Mesh(
                new THREE.BoxGeometry(crossArmLength, crossArmThickness, crossArmThickness),
                crossMaterial
            );
            protoGalaxyGroup.add(horizontalArm);

            const verticalArm = new THREE.Mesh(
                new THREE.BoxGeometry(crossArmThickness, crossArmLength, crossArmThickness),
                crossMaterial
            );
            protoGalaxyGroup.add(verticalArm);

            const depthArm = new THREE.Mesh(
                new THREE.BoxGeometry(crossArmThickness, crossArmThickness, crossArmLength),
                crossMaterial
            );
            protoGalaxyGroup.add(depthArm);

            protoGalaxyGroup.position.copy(position); // Use the provided position
            protoGalaxyGroup.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.02,
                (Math.random() - 0.5) * 0.02,
                (Math.random() - 0.5) * 0.02
            );

            scene.add(protoGalaxyGroup);
            protoGalaxies.push(protoGalaxyGroup);
            document.getElementById('numGalaxiesValue').textContent = protoGalaxies.length;
        }

        /**
         * Removes a specific proto-galaxy from the simulation and applies an ejection force to nearby particles.
         * @param {THREE.Group} galaxyToRemove The THREE.Group object representing the galaxy to remove.
         * @param {boolean} isEventRemoved True if this galaxy is removed by a cosmic event, false otherwise.
         */
        function removeSpecificProtoGalaxy(galaxyToRemove, isEventRemoved = false) {
            if (!isGameActive) return;
            if (!galaxyToRemove) {
                console.log("No galaxy object provided for removal.");
                return;
            }

            // If removing a formed galaxy, decrement the count
            if (galaxyToRemove.isFormed) {
                galaxiesFormedCount--;
                document.getElementById('galaxiesFormedCount').textContent = galaxiesFormedCount;
            }

            const galaxyPosition = galaxyToRemove.position.clone();
            const galaxyMass = galaxyToRemove.mass;

            scene.remove(galaxyToRemove);
            // Remove from the array
            const index = protoGalaxies.indexOf(galaxyToRemove);
            if (index > -1) {
                protoGalaxies.splice(index, 1);
            }
            document.getElementById('numGalaxiesValue').textContent = protoGalaxies.length;

            const positions = particles.geometry.attributes.position.array;
            const velocities = particles.geometry.attributes.velocity.array;

            for (let i = 0; i < currentParticleCount; i++) {
                const i3 = i * 3;
                // Skip sucked particles
                if (particles.geometry.attributes.sucked.array[i]) continue;

                const particlePos = new THREE.Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]);

                const dx = particlePos.x - galaxyPosition.x;
                const dy = particlePos.y - galaxyPosition.y;
                const dz = particlePos.z - galaxyPosition.z;
                const distanceSq = dx * dx + dy * dy + dz * dz;
                const distance = Math.sqrt(distanceSq);

                if (distance < removalEjectionRadius && distance > 0) {
                    const effectiveDistanceSq = distanceSq + softeningFactor;
                    const forceMagnitude = (gravitationalConstant * removalForceMultiplier * galaxyMass) / effectiveDistanceSq;

                    const ejectionDirectionX = dx / distance;
                    const ejectionDirectionY = dy / distance;
                    const ejectionDirectionZ = dz / distance;

                    velocities[i3] += ejectionDirectionX * forceMagnitude;
                    velocities[i3 + 1] += ejectionDirectionY * forceMagnitude;
                    velocities[i3 + 2] += ejectionDirectionZ * forceMagnitude;

                    const currentVelocityMagnitude = Math.sqrt(
                        velocities[i3] * velocities[i3] +
                        velocities[i3 + 1] * velocities[i3 + 1] +
                        velocities[i3 + 2] * velocities[i3 + 2]
                    );
                    if (currentVelocityMagnitude > speedOfLight) {
                        const scaleFactor = speedOfLight / currentVelocityMagnitude;
                        velocities[i3] *= scaleFactor;
                        velocities[i3 + 1] *= scaleFactor;
                        velocities[i3 + 2] *= scaleFactor;
                    }
                }
            }
            particles.geometry.attributes.velocity.needsUpdate = true;
        }

        // Function to measure entropy based on particle distribution
        function measureEntropy() {
            if (!particles || !particles.geometry || !particles.geometry.attributes.position || !particles.geometry.attributes.sucked) {
                return 0; // Return 0 or handle initial state where particles might not be ready
            }
            const positions = particles.geometry.attributes.position.array;
            const suckedParticles = particles.geometry.attributes.sucked.array;

            let totalSquaredDistance = 0;
            let activeParticleCountForEntropy = 0; // Use a distinct count for entropy calculation

            for (let i = 0; i < currentParticleCount; i++) { // Iterate only through currently active particles
                if (!suckedParticles[i]) { // Only consider active, non-sucked particles
                    const i3 = i * 3;
                    const x = positions[i3];
                    const y = positions[i3 + 1];
                    const z = positions[i3 + 2];
                    totalSquaredDistance += (x * x + y * y + z * z); // Squared distance from origin
                    activeParticleCountForEntropy++;
                }
            }

            if (activeParticleCountForEntropy === 0) {
                return 0; // If no active particles, entropy is considered 0 (all ordered to center or removed)
            }

            return totalSquaredDistance / activeParticleCountForEntropy; // Average squared distance
        }

        // Function to update the entropy display in the UI
        function updateEntropyDisplay() {
            // Only update if the game is active or if big crunch is ongoing
            if (isGameActive || isBigCrunchActive) {
                entropyValueElement.textContent = measureEntropy().toFixed(0); // Display with 2 decimal places
            }
        }

        function checkGalaxyFormation() {
            const positions = particles.geometry.attributes.position.array;
            let currentFormedCount = 0;

            protoGalaxies.forEach(galaxy => {
                let particlesInInfluence = 0; // Reset for each galaxy
                for (let i = 0; i < currentParticleCount; i++) { // Iterate over current active particles
                    const i3 = i * 3;
                    if (particles.geometry.attributes.sucked && particles.geometry.attributes.sucked.array[i]) {
                        continue;
                    }
                    const particlePos = new THREE.Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]);
                    if (particlePos.distanceTo(galaxy.position) < galaxyFormationRadius) {
                        particlesInInfluence++;
                    }
                }

                if (particlesInInfluence >= minParticlesForGalaxy) {
                    if (!galaxy.isFormed) {
                        galaxy.isFormed = true;
                        galaxy.children.forEach(mesh => {
                            if (mesh.material) {
                                mesh.material.color.set(0x00ff00);
                            }
                        });
                    }
                    currentFormedCount++;
                } else {
                    if (galaxy.isFormed) {
                        galaxy.isFormed = false;
                        galaxy.children.forEach(mesh => {
                            if (mesh.material) {
                                mesh.material.color.set(0xffff00);
                            }
                        });
                    }
                }
            });

            if (currentFormedCount !== galaxiesFormedCount) {
                galaxiesFormedCount = currentFormedCount;
                document.getElementById('galaxiesFormedCount').textContent = galaxiesFormedCount;
            }

            if (galaxiesFormedCount >= targetGalaxiesNeeded) {
                endGame(true);
            }
        }

        function endGame(isWin) {
            isGameActive = false;
            clearInterval(gameTimerInterval);
            clearInterval(cosmicEventTimer);
            clearInterval(entropyTimerInterval); // Clear entropy timer on game end

            if (isWin) {
                messageText.textContent = `You Win! Formed ${galaxiesFormedCount} Galaxies!`;
            } else {
                messageText.textContent = `You formed ${galaxiesFormedCount} of ${targetGalaxiesNeeded} galaxies.`;
            }
            messageScreen.style.display = 'flex';
            restartGameBtn.style.display = 'inline-block'; // Show play again button
        }

        // --- Three.js Initialization ---

        let animationFrameId;

        function initThreeJSScene() {
            if (scene) {
                // Dispose of old objects if restarting
                scene.children.forEach(child => {
                    // Check if child has a dispose method (e.g., for geometries/materials)
                    if (child.geometry && child.geometry.dispose) child.geometry.dispose();
                    if (child.material && child.material.dispose) child.material.dispose();
                    // For groups, iterate children and dispose
                    if (child.children) {
                        child.children.forEach(grandchild => {
                            if (grandchild.geometry && grandchild.geometry.dispose) grandchild.geometry.dispose();
                            if (grandchild.material && grandchild.material.dispose) grandchild.material.dispose();
                        });
                    }
                    scene.remove(child);
                });
            }

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 100;

            if (renderer) {
                renderer.setSize(window.innerWidth, window.innerHeight);
            } else {
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                canvasContainer.appendChild(renderer.domElement);
            }

            if (typeof THREE.OrbitControls === 'function') {
                if (controls) {
                    controls.dispose();
                }
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.screenSpacePanning = false;
                controls.maxDistance = 500;
                controls.minDistance = 10;
                controls.enabled = true;
            } else {
                console.error("THREE.OrbitControls is not a constructor. Camera controls will not be available.");
                controls = null;
            }
        }

        function createParticles() {
            if (particles) {
                particles.geometry.dispose();
                particles.material.dispose();
                scene.remove(particles);
            }

            const geometry = new THREE.BufferGeometry();
            // Allocate space for maxParticleCapacity, but only fill initialNumParticles
            const positions = new Float32Array(maxParticleCapacity * 3);
            const velocities = new Float32Array(maxParticleCapacity * 3);
            const colors = new Float32Array(maxParticleCapacity * 3);
            const sucked = new Uint8Array(maxParticleCapacity); // 0 = not sucked, 1 = sucked/inactive

            const singularityRadius = 0.01;

            for (let i = 0; i < initialNumParticles; i++) {
                const i3 = i * 3;

                positions[i3] = (Math.random() - 0.5) * singularityRadius;
                positions[i3 + 1] = (Math.random() - 0.5) * singularityRadius;
                positions[i3 + 2] = (Math.random() - 0.5) * singularityRadius;

                const direction = new THREE.Vector3(
                    Math.random() - 0.5,
                    Math.random() - 0.5,
                    Math.random() - 0.5
                ).normalize();

                const initialSpeed = Math.min(Math.random() * 0.5 + 0.1, speedOfLight);

                velocities[i3] = direction.x * initialSpeed;
                velocities[i3 + 1] = direction.y * initialSpeed;
                velocities[i3 + 2] = direction.z * initialSpeed;

                colors[i3] = Math.random();
                colors[i3 + 1] = Math.random();
                colors[i3 + 2] = Math.random();

                sucked[i] = 0; // Initially not sucked
            }

            // For the remaining capacity, initialize them as "sucked" or inactive
            for (let i = initialNumParticles; i < maxParticleCapacity; i++) {
                const i3 = i * 3;
                positions[i3] = 100000; // Place far away
                positions[i3 + 1] = 100000;
                positions[i3 + 2] = 100000;
                velocities[i3] = 0;
                velocities[i3 + 1] = 0;
                velocities[i3 + 2] = 0;
                colors[i3] = 0; colors[i3+1] = 0; colors[i3+2] = 0;
                sucked[i] = 1; // Mark as inactive/sucked
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('sucked', new THREE.BufferAttribute(sucked, 1));

            const material = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // New function to create wormhole visuals (entry, exit, and grid tunnel)
        function createWormholeVisuals(entryPos, exitPos) {
            const wormholeGroup = new THREE.Group();

            // Wormhole material (same for rings and grid)
            const wormholeMaterial = new THREE.MeshBasicMaterial({ color: 0x8A2BE2, transparent: true, opacity: 0.7, side: THREE.DoubleSide, blending: THREE.AdditiveBlending });
            const gridLineMaterial = new THREE.LineBasicMaterial({ color: 0x8A2BE2, transparent: true, opacity: 0.5 });

            const entryRadius = wormholeSize * funnelEntryMultiplier;
            const exitRadius = wormholeSize * funnelExitMultiplier; // Use the new funnelExitMultiplier

            // Generate a control point for the curve
            const midPoint = new THREE.Vector3().addVectors(entryPos, exitPos).multiplyScalar(0.5);
            const direction = new THREE.Vector3().subVectors(exitPos, entryPos).normalize();
            const perpendicular = new THREE.Vector3(1, 0, 0).cross(direction).normalize(); // Get a perpendicular vector
            if (perpendicular.lengthSq() === 0) { // If direction is parallel to (1,0,0), pick another axis
                perpendicular.set(0, 1, 0).cross(direction).normalize();
            }
            const curveOffset = (Math.random() - 0.5) * (entryPos.distanceTo(exitPos) * 0.5); // Random offset for curvature
            const controlPoint = new THREE.Vector3().addVectors(midPoint, perpendicular.multiplyScalar(curveOffset));

            // Create the curved path
            const curve = new THREE.CatmullRomCurve3([entryPos, controlPoint, exitPos]);

            // Entry Ring
            const entryGeometry = new THREE.RingGeometry(entryRadius, entryRadius * 1.1, 32);
            const entryMesh = new THREE.Mesh(entryGeometry, wormholeMaterial);
            entryMesh.position.copy(entryPos);
            // Orient entry ring
            const entryTangent = curve.getTangent(0).normalize();
            const entryQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), entryTangent);
            entryMesh.quaternion.copy(entryQuaternion);
            wormholeGroup.add(entryMesh);

            // Exit Ring (smaller)
            const exitGeometry = new THREE.RingGeometry(exitRadius, exitRadius * 1.1, 32);
            const exitMesh = new THREE.Mesh(exitGeometry, wormholeMaterial);
            exitMesh.position.copy(exitPos);
            // Orient exit ring
            const exitTangent = curve.getTangent(1).normalize();
            const exitQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), exitTangent);
            exitMesh.quaternion.copy(exitQuaternion);
            wormholeGroup.add(exitMesh);

            // Create the grid tunnel along the curve
            const gridSegments = 15; // More segments for smoother curve
            const numPointsPerRing = 16; // Resolution of each ring
            const points = [];
            const indices = [];

            for (let i = 0; i < gridSegments; i++) {
                const t = i / (gridSegments - 1); // Interpolation factor (0 to 1)
                const currentRadius = THREE.MathUtils.lerp(entryRadius, exitRadius, t); // Interpolate radius from entry to exit
                const currentPosition = curve.getPoint(t); // Get position along the curve
                const tangent = curve.getTangent(t).normalize(); // Get tangent at this point

                // Calculate perpendicular vectors for ring orientation based on tangent
                const tempUp = new THREE.Vector3(0, 1, 0);
                let axisX = new THREE.Vector3().crossVectors(tangent, tempUp).normalize();
                if (axisX.lengthSq() < 0.001) { // If tangent is nearly parallel to Y, use X-axis as tempUp
                    axisX.set(1, 0, 0).cross(tangent).normalize();
                }
                const axisY = new THREE.Vector3().crossVectors(tangent, axisX).normalize();

                const baseIndex = i * numPointsPerRing;

                for (let j = 0; j < numPointsPerRing; j++) {
                    const angle = (j / numPointsPerRing) * Math.PI * 2;
                    const x = currentRadius * Math.cos(angle);
                    const y = currentRadius * Math.sin(angle);

                    // Rotate points to be perpendicular to the wormhole's direction (tangent)
                    const rotatedPoint = new THREE.Vector3()
                        .addScaledVector(axisX, x)
                        .addScaledVector(axisY, y);

                    const finalPoint = new THREE.Vector3().addVectors(currentPosition, rotatedPoint);
                    points.push(finalPoint.x, finalPoint.y, finalPoint.z);

                    // Add indices for the current ring (horizontal lines of the grid)
                    if (j < numPointsPerRing - 1) {
                        indices.push(baseIndex + j, baseIndex + j + 1);
                    } else {
                        indices.push(baseIndex + j, baseIndex); // Close the ring
                    }

                    // Add indices for longitudinal lines (connecting to previous ring vertically)
                    if (i > 0) {
                        const prevBaseIndex = (i - 1) * numPointsPerRing;
                        indices.push(baseIndex + j, prevBaseIndex + j);
                    }
                }
            }

            const gridGeometry = new THREE.BufferGeometry();
            gridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
            gridGeometry.setIndex(indices);

            const gridMesh = new THREE.LineSegments(gridGeometry, gridLineMaterial);
            wormholeGroup.add(gridMesh);

            return {
                group: wormholeGroup,
                entryMesh: entryMesh,
                exitMesh: exitMesh,
                gridMesh: gridMesh
            };
        }

        /**
         * Adds a new white hole to the simulation at the given position.
         * @param {THREE.Vector3} position The 3D coordinates where the white hole will be placed.
         */
        function addWhiteHole(position) {
            const whiteHoleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending });
            const whiteHoleGeometry = new THREE.SphereGeometry(whiteHoleSize, 16, 16);
            const whiteHoleMesh = new THREE.Mesh(whiteHoleGeometry, whiteHoleMaterial);
            whiteHoleMesh.position.copy(position);
            scene.add(whiteHoleMesh);

            // Add a point light to make it glow
            const whiteHoleLight = new THREE.PointLight(0xffffff, 1, 50); // Color, intensity, distance
            whiteHoleLight.position.copy(position);
            scene.add(whiteHoleLight);

            whiteHoles.push({
                mesh: whiteHoleMesh,
                light: whiteHoleLight,
                position: position,
                spawnTime: Date.now(),
                emitCounter: 0, // Counter to track how many particles it has emitted
                lastEmitTime: Date.now()
            });
        }

        /**
         * Emits new particles from a given white hole.
         * Particles are added to the existing particle buffer if capacity allows.
         * @param {object} whiteHole The white hole object.
         */
        function emitParticlesFromWhiteHole(whiteHole) {
            const positions = particles.geometry.attributes.position.array;
            const velocities = particles.geometry.attributes.velocity.array;
            const colors = particles.geometry.attributes.color.array;
            const sucked = particles.geometry.attributes.sucked.array;

            const emitStartCount = currentParticleCount;
            let particlesToEmit = whiteHoleEmitCount;

            // Ensure we don't exceed maxParticleCapacity
            if (emitStartCount + particlesToEmit > maxParticleCapacity) {
                particlesToEmit = maxParticleCapacity - emitStartCount;
            }

            if (particlesToEmit <= 0) return; // No space or nothing to emit

            for (let i = 0; i < particlesToEmit; i++) {
                const particleIndex = emitStartCount + i;
                const i3 = particleIndex * 3;

                // Position new particle at white hole's location
                positions[i3] = whiteHole.position.x;
                positions[i3 + 1] = whiteHole.position.y;
                positions[i3 + 2] = whiteHole.position.z;

                // Give it an outward velocity
                const direction = new THREE.Vector3(
                    Math.random() - 0.5,
                    Math.random() - 0.5,
                    Math.random() - 0.5
                ).normalize();
                const initialSpeed = Math.min(Math.random() * 0.5 + 0.1, speedOfLight);

                velocities[i3] = direction.x * initialSpeed;
                velocities[i3 + 1] = direction.y * initialSpeed;
                velocities[i3 + 2] = direction.z * initialSpeed;

                // Random color for new particles
                colors[i3] = Math.random();
                colors[i3 + 1] = Math.random();
                colors[i3 + 2] = Math.random();

                sucked[particleIndex] = 0; // Mark as active
            }

            currentParticleCount += particlesToEmit;
            whiteHole.emitCounter += particlesToEmit; // Track emitted particles by this white hole

            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.velocity.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
            particles.geometry.attributes.sucked.needsUpdate = true;

            particleCountElement.textContent = currentParticleCount - suckedParticleCount;
            console.log(`White hole emitted ${particlesToEmit} particles. Total active: ${currentParticleCount}`);
        }


        // --- Interaction Logic ---
        function onCanvasClick(event) {
            if (!isGameActive) return; // Only allow clicks if game is active

            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update the raycaster with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            if (gameMode === 'place') {
                if (cosmicEnergy > 0) {
                    // Project a point some distance in front of the camera along the ray
                    // This creates a point in 3D space where the user clicked.
                    const clickPosition = new THREE.Vector3();
                    // Project at a distance from camera, roughly in the center of the simulation space
                    raycaster.ray.at(camera.position.length(), clickPosition);

                    placeProtoGalaxyAtPosition(clickPosition);
                    cosmicEnergy--;
                    document.getElementById('cosmicEnergyValue').textContent = cosmicEnergy;
                }
                gameMode = 'play';
                controls.enabled = true; // Re-enable orbit controls
                resetButtonStates(); // Reset button states after action
            } else if (gameMode === 'remove') {
                if (protoGalaxies.length > 0) {
                    // Find the closest galaxy to the ray
                    let closestGalaxy = null;
                    let minDistance = Infinity;
                    const intersectionThreshold = 5; // How close the ray needs to be to a galaxy to select it

                    protoGalaxies.forEach(galaxy => {
                        const distance = raycaster.ray.distanceToPoint(galaxy.position);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestGalaxy = galaxy;
                        }
                    });

                    if (closestGalaxy && minDistance < intersectionThreshold) {
                        removeSpecificProtoGalaxy(closestGalaxy);
                        cosmicEnergy++; // Refund energy for removing
                        document.getElementById('cosmicEnergyValue').textContent = cosmicEnergy;
                    }
                }
                gameMode = 'play';
                controls.enabled = true; // Re-enable orbit controls
                resetButtonStates(); // Reset button states after action
            } else { // gameMode === 'play'
                controls.enabled = true;
            }
        }

        // Function to reset button text and color to default
        function resetButtonStates() {
            placeGalaxyBtn.textContent = "Place Attractor";
            placeGalaxyBtn.classList.remove('active-place');
            removeGalaxyBtn.textContent = "Remove Attractor";
            removeGalaxyBtn.classList.remove('active-remove');
            messageScreen.style.display = 'none'; // Ensure message screen is hidden
            restartGameBtn.style.display = 'inline-block'; // Ensure restart button is visible if game is over
        }


        // Animation loop
        function animate() {
            animationFrameId = requestAnimationFrame(animate);

            if (controls) {
                controls.update(); // Always update controls for camera movement
            }
            renderer.render(scene, camera); // Always render

            // --- Big Crunch Logic (Overrides normal game physics) ---
            if (isBigCrunchActive) {
                const crunchCenter = new THREE.Vector3(0, 0, 0);
                const crunchForceMagnitude = 200.0; // Increased significantly for dramatic effect
                const crunchParticleThreshold = 10; // Smaller threshold for hiding particles

                const positions = particles.geometry.attributes.position.array;
                const velocities = particles.geometry.attributes.velocity.array;
                const colors = particles.geometry.attributes.color.array;
                const suckedParticles = particles.geometry.attributes.sucked.array;

                for (let i = 0; i < currentParticleCount; i++) { // Iterate over current active particles
                    const i3 = i * 3;

                    if (suckedParticles[i]) continue; // Skip particles already sucked

                    const currentX = positions[i3];
                    const currentY = positions[i3 + 1];
                    const currentZ = positions[i3 + 2];

                    const dx = crunchCenter.x - currentX;
                    const dy = crunchCenter.y - currentY;
                    const dz = crunchCenter.z - currentZ;
                    const distanceSq = dx * dx + dy * dy + dz * dz;
                    const distance = Math.sqrt(distanceSq);

                    if (distance < crunchParticleThreshold) {
                        // Particle has effectively crunched, hide it
                        suckedParticles[i] = 1;
                        suckedParticleCount++; // Count for crunch too
                        currentParticleCount--; // Particles effectively removed from active count
                        positions[i3] = 100000; // Move far away
                        positions[i3 + 1] = 100000;
                        positions[i3 + 2] = 100000;
                        colors[i3] = 0; colors[i3+1] = 0; colors[i3+2] = 0; // Make it black/invisible
                        continue;
                    }

                    const effectiveDistanceSq = distanceSq + softeningFactor; // Still use softening factor
                    const forceMagnitude = (gravitationalConstant * crunchForceMagnitude) / effectiveDistanceSq;

                    const directionX = dx / distance;
                    const directionY = dy / distance;
                    const directionZ = dz / distance;

                    velocities[i3] += directionX * forceMagnitude;
                    velocities[i3 + 1] += directionY * forceMagnitude;
                    velocities[i3 + 2] += directionZ * forceMagnitude;

                    // Cap velocity, but allow faster than normal game play for crunch
                    const currentVelocityMagnitude = Math.sqrt(
                        velocities[i3] * velocities[i3] +
                        velocities[i3 + 1] * velocities[i3 + 1] +
                        velocities[i3 + 2] * velocities[i3 + 2]
                    );
                    const crunchSpeedCap = speedOfLight * 20; // Allow particles to move much faster
                    if (currentVelocityMagnitude > crunchSpeedCap) {
                        const scaleFactor = crunchSpeedCap / currentVelocityMagnitude;
                        velocities[i3] *= scaleFactor;
                        velocities[i3 + 1] *= scaleFactor;
                        velocities[i3 + 2] *= scaleFactor;
                    }

                    positions[i3] += velocities[i3] * 1.0; // Use a fixed step size for crunch
                    positions[i3 + 1] += velocities[i3 + 1] * 1.0;
                    positions[i3 + 2] += velocities[i3 + 2] * 1.0;
                }
                particles.geometry.attributes.position.needsUpdate = true;
                particles.geometry.attributes.sucked.needsUpdate = true;
                particles.geometry.attributes.color.needsUpdate = true;
                suckedParticleCountElement.textContent = suckedParticleCount; // Update UI during crunch
                particleCountElement.textContent = currentParticleCount - suckedParticleCount;

                return; // Skip the rest of the game physics during big crunch
            }

            // --- Normal game physics (only runs if not isBigCrunchActive and game is active) ---
            if (!isGameActive) return; // If game is over but not in crunch, just render and return

            const positions = particles.geometry.attributes.position.array;
            const velocities = particles.geometry.attributes.velocity.array;
            const colors = particles.geometry.attributes.color.array;
            const suckedParticles = particles.geometry.attributes.sucked.array;

            // Existing proto-galaxy movement
            protoGalaxies.forEach(galaxy => {
                galaxy.position.x += galaxy.velocity.x;
                galaxy.position.y += galaxy.velocity.y;
                galaxy.position.z += galaxy.velocity.z;

                if (Math.abs(galaxy.position.x) > protoGalaxyInitialSpread * 4) galaxy.velocity.x *= -1;
                if (Math.abs(galaxy.position.y) > protoGalaxyInitialSpread * 4) galaxy.velocity.y *= -1;
                if (Math.abs(galaxy.position.z) > protoGalaxyInitialSpread * 4) galaxy.velocity.z *= -1;
            });

            // Existing black hole physics (sucking particles)
            const currentTime = Date.now();
            for (let i = blackHoles.length - 1; i >= 0; i--) {
                const bh = blackHoles[i];
                if ((currentTime - bh.spawnTime) / 1000 > blackHoleDuration) {
                    scene.remove(bh.mesh);
                    blackHoles.splice(i, 1);
                    console.log("Black hole expired and removed.");
                    continue;
                }

                for (let j = 0; j < currentParticleCount; j++) { // Iterate over current active particles
                    const j3 = j * 3;
                    if (suckedParticles[j]) continue;

                    const particlePos = new THREE.Vector3(positions[j3], positions[j3 + 1], positions[j3 + 2]);
                    const distance = particlePos.distanceTo(bh.mesh.position);

                    const dx = bh.mesh.position.x - particlePos.x;
                    const dy = bh.mesh.position.y - particlePos.y;
                    const dz = bh.mesh.position.z - particlePos.z;
                    const distanceToBhSq = dx * dx + dy * dy + dz * dz;
                    const distanceToBh = Math.sqrt(distanceToBhSq);

                    if (distanceToBh > 0) {
                        const effectiveDistanceToBhSq = distanceToBhSq + softeningFactor;
                        const forceMagnitudeBh = (gravitationalConstant * bh.mass) / effectiveDistanceToBhSq;

                        const directionXBh = dx / distanceToBh;
                        const directionYBh = dy / distanceToBh;
                        const directionZBh = dz / distanceToBh;

                        velocities[j3] += directionXBh * forceMagnitudeBh;
                        velocities[j3 + 1] += directionYBh * forceMagnitudeBh;
                        velocities[j3 + 2] += directionZBh * forceMagnitudeBh;
                    }


                    if (distance < bh.suckRadius) {
                        suckedParticles[j] = 1;
                        suckedParticleCount++;
                        currentParticleCount--; // Particle is now inactive/sucked
                        positions[j3] = 100000;
                        positions[j3 + 1] = 100000;
                        positions[j3 + 2] = 100000;
                        colors[j3] = 0; colors[j3+1] = 0; colors[j3+2] = 0;
                    }
                }
            }
            particles.geometry.attributes.sucked.needsUpdate = true;
            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
            suckedParticleCountElement.textContent = suckedParticleCount;
            particleCountElement.textContent = currentParticleCount - suckedParticleCount;

            // Wormhole physics (sucking and spitting particles)
            for (let i = wormholes.length - 1; i >= 0; i--) {
                const wh = wormholes[i];
                if ((currentTime - wh.spawnTime) / 1000 > wh.duration) {
                    scene.remove(wh.group);
                    if (wh.entryMesh.geometry) wh.entryMesh.geometry.dispose();
                    if (wh.entryMesh.material) wh.entryMesh.material.dispose();
                    if (wh.exitMesh.geometry) wh.exitMesh.geometry.dispose();
                    if (wh.exitMesh.material) wh.exitMesh.material.dispose();
                    if (wh.gridMesh.geometry) wh.gridMesh.geometry.dispose();
                    if (wh.gridMesh.material) wh.gridMesh.material.dispose();
                    wormholes.splice(i, 1);
                    console.log("Wormhole closed and removed.");
                    continue;
                }

                for (let j = 0; j < currentParticleCount; j++) { // Iterate over current active particles
                    const j3 = j * 3;
                    if (suckedParticles[j]) continue;

                    const particlePos = new THREE.Vector3(positions[j3], positions[j3 + 1], positions[j3 + 2]);
                    const distanceToEntry = particlePos.distanceTo(wh.entryPosition);

                    if (distanceToEntry < wh.suckRadius) {
                        // Pull particle towards entry point
                        const dx = wh.entryPosition.x - particlePos.x;
                        const dy = wh.entryPosition.y - particlePos.y;
                        const dz = wh.entryPosition.z - particlePos.z;
                        const distanceSq = dx * dx + dy * dy + dz * dz;
                        const distance = Math.sqrt(distanceSq);

                        if (distance > 0.5) {
                            const effectiveDistanceSq = distanceSq + softeningFactor;
                            const forceMagnitude = (gravitationalConstant * 200) / effectiveDistanceSq;

                            const directionX = dx / distance;
                            const directionY = dy / distance;
                            const directionZ = dz / distance;

                            velocities[j3] += directionX * forceMagnitude;
                            velocities[j3 + 1] += directionY * forceMagnitude;
                            velocities[j3 + 2] += directionZ * forceMagnitude;
                        } else {
                            // Particle is at the entry, teleport it to the exit and spit it out
                            positions[j3] = wh.exitPosition.x;
                            positions[j3 + 1] = wh.exitPosition.y;
                            positions[j3 + 2] = wh.exitPosition.z;

                            // Give it an outward velocity from the exit point
                            const spitDirection = new THREE.Vector3(
                                Math.random() - 0.5,
                                Math.random() - 0.5,
                                Math.random() - 0.5
                            ).normalize();

                            velocities[j3] = spitDirection.x * wh.spitForce;
                            velocities[j3 + 1] = spitDirection.y * wh.spitForce;
                            velocities[j3 + 2] = spitDirection.z * wh.spitForce;
                        }
                    }
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.velocity.needsUpdate = true;

            // White Hole physics (emitting and repelling particles) (NEW)
            for (let i = whiteHoles.length - 1; i >= 0; i--) {
                const wh = whiteHoles[i];
                if ((currentTime - wh.spawnTime) / 1000 > whiteHoleDuration) {
                    scene.remove(wh.mesh);
                    if(wh.light) scene.remove(wh.light);
                    if (wh.mesh.geometry) wh.mesh.geometry.dispose();
                    if (wh.mesh.material) wh.mesh.material.dispose();
                    whiteHoles.splice(i, 1);
                    console.log("White hole expired and removed.");
                    continue;
                }

                // Emit particles periodically
                if ((currentTime - wh.lastEmitTime) / 1000 > 0.5 && currentParticleCount < maxParticleCapacity) { // Emit every 0.5 seconds
                    emitParticlesFromWhiteHole(wh);
                    wh.lastEmitTime = currentTime;
                }

                // Apply repulsive force to nearby particles
                for (let j = 0; j < currentParticleCount; j++) { // Iterate over current active particles
                    const j3 = j * 3;
                    if (suckedParticles[j]) continue;

                    const particlePos = new THREE.Vector3(positions[j3], positions[j3 + 1], positions[j3 + 2]);
                    const distance = particlePos.distanceTo(wh.position);

                    if (distance > 0 && distance < whiteHoleSize * 5) { // Apply repulsion within a certain range
                        const dx = particlePos.x - wh.position.x;
                        const dy = particlePos.y - wh.position.y;
                        const dz = particlePos.z - wh.position.z;
                        const distanceSq = dx * dx + dy * dy + dz * dz;
                        const effectiveDistanceSq = distanceSq + softeningFactor; // Softening for smoother force

                        const forceMagnitude = (whiteHoleRepulsionForce / effectiveDistanceSq) * 10; // Stronger repulsion

                        const directionX = dx / distance;
                        const directionY = dy / distance;
                        const directionZ = dz / distance;

                        velocities[j3] += directionX * forceMagnitude;
                        velocities[j3 + 1] += directionY * forceMagnitude;
                        velocities[j3 + 2] += directionZ * forceMagnitude;
                    }
                }
            }
            particles.geometry.attributes.velocity.needsUpdate = true;


            for (let i = 0; i < currentParticleCount; i++) { // Iterate over current active particles
                const i3 = i * 3;

                if (suckedParticles[i]) continue;

                const currentX = positions[i3];
                const currentY = positions[i3 + 1];
                const currentZ = positions[i3 + 2];

                let minDistanceSq = Infinity;
                let closestGravitySource = null;

                for (let j = 0; j < protoGalaxies.length; j++) {
                    const galaxy = protoGalaxies[j];
                    const dx = galaxy.position.x - currentX;
                    const dy = galaxy.position.y - currentY;
                    const dz = galaxy.position.z - currentZ;
                    const distanceSq = dx * dx + dy * dy + dz * dz;

                    if (distanceSq < minDistanceSq) {
                        minDistanceSq = distanceSq;
                        closestGravitySource = galaxy;
                    }
                }

                if (closestGravitySource) {
                    const distance = Math.sqrt(minDistanceSq);

                    const effectiveDistanceSq = minDistanceSq + softeningFactor;
                    const forceMagnitude = (gravitationalConstant * closestGravitySource.mass) / effectiveDistanceSq;

                    const directionX = (closestGravitySource.position.x - currentX) / distance;
                    const directionY = (closestGravitySource.position.y - currentY) / distance;
                    const directionZ = (closestGravitySource.position.z - currentZ) / distance;

                    velocities[i3] += directionX * forceMagnitude;
                    velocities[i3 + 1] += directionY * forceMagnitude;
                    velocities[i3 + 2] += directionZ * forceMagnitude;
                }

                const currentVelocityMagnitude = Math.sqrt(
                    velocities[i3] * velocities[i3] +
                    velocities[i3 + 1] * velocities[i3 + 1] +
                    velocities[i3 + 2] * velocities[i3 + 2]
                );

                if (currentVelocityMagnitude > speedOfLight) {
                    const scaleFactor = speedOfLight / currentVelocityMagnitude;
                    velocities[i3] *= scaleFactor;
                    velocities[i3 + 1] *= scaleFactor;
                    velocities[i3 + 2] *= scaleFactor;
                }

                positions[i3] += velocities[i3] * expansionSpeed;
                positions[i3 + 1] += velocities[i3 + 1] * expansionSpeed;
                positions[i3 + 2] += velocities[i3 + 2] * expansionSpeed;
            }
            particles.geometry.attributes.position.needsUpdate = true;

            checkGalaxyFormation();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.onload = function() {
            initThreeJSScene();

            // Set initial volume
            backgroundMusic.volume = volumeSlider.value;

            // Event listener for volume slider
            volumeSlider.addEventListener('input', () => {
                backgroundMusic.volume = volumeSlider.value;
            });


            placeGalaxyBtn.addEventListener('click', () => {
                if (isGameActive && cosmicEnergy > 0) {
                    gameMode = 'place';
                    controls.enabled = false; // Disable orbit controls when in placement mode
                    removeGalaxyBtn.textContent = "Remove Attractor"; // Ensure other button is reset
                    removeGalaxyBtn.classList.remove('active-remove'); // Ensure other button is reset
                    placeGalaxyBtn.textContent = "Place";
                    placeGalaxyBtn.classList.add('active-place');
                }
            });

            removeGalaxyBtn.addEventListener('click', () => {
                if (isGameActive && protoGalaxies.length > 0) {
                    gameMode = 'remove';
                    controls.enabled = false; // Disable orbit controls when in removal mode
                    placeGalaxyBtn.textContent = "Place Attractor"; // Ensure other button is reset
                    placeGalaxyBtn.classList.remove('active-place'); // Ensure other button is reset
                    removeGalaxyBtn.textContent = "Remove";
                    removeGalaxyBtn.classList.add('active-remove');
                }
            });

            canvasContainer.addEventListener('click', onCanvasClick, false);
            restartGameBtn.addEventListener('click', startGame);

            // Global click listener to ensure music starts if not already playing (due to autoplay restrictions)
            document.addEventListener('click', () => {
                if (backgroundMusic.paused) {
                    backgroundMusic.play().catch(error => {
                        console.log("Playback failed on user click:", error);
                    });
                }
            }, { once: true }); // Only run this once            

            window.addEventListener('resize', onWindowResize, false);

            messageScreen.style.display = 'flex';
            messageText.textContent = "";
            restartGameBtn.textContent = "Start Game";
            gameControls.style.display = 'none'; // Hide controls on initial load
        };
    </script>
</body>
</html>