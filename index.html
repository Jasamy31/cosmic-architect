<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Architect</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            font-family: 'Inter', sans-serif;
            background-color: #0d0d0d; /* Dark background for space feel */
            color: #e0e0e0;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .info-panel {
            background-color: rgba(31, 41, 55, 0.7); /* bg-gray-800 with opacity */
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* shadow-lg */
            z-index: 10;
        }
        .game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0);
            padding: 2rem 3rem;
            border-radius: 10px;
            text-align: center;
            font-size: 2rem;
            font-weight: bold;
            color: #ffffff;
            z-index: 20;
            display: none; /* Hidden by default */
        }
        .game-button {
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            background-color: #4f46e5; /* indigo-600 */
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-right: 0.5rem;
            text-align: center;
            display: inline-block;
        }
        .game-button:hover {
            background-color: #4338ca; /* indigo-700 */
        }
        /* New classes for active button states */
        .game-button.active-place {
            background-color: #10b981; /* green-500 */
        }
        .game-button.active-remove {
            background-color: #ef4444; /* red-500 */
        }
        .control-panel {
            background-color: rgba(31, 41, 55, 0);
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            z-index: 10;
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen">
    <audio id="backgroundMusic" src="sounds/continuous-bass-rumble-336529.mp3" loop preload="auto" volume="1">
        Your browser does not support the audio element.
    </audio>

    <div class="volume-control">
        <span>Volume:</span>
        <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.2">
    </div>

    <div class="info-panel absolute top-4 left-4 max-w-xs md:max-w-md lg:max-w-lg">
        <h1 class="text-2xl font-bold mb-2 text-white">Cosmic Architect</h1>
        <p class="hidden md:block text-sm text-gray-300">
            Guide the formation of galaxies! Place or remove gravitational centers to attract
            particles and form stable cosmic structures.
            Use your mouse to orbit. Click a 'Place' or 'Remove' button, then click on the simulation.
        </p>
        <div class="mt-4 text-sm text-gray-400">
            <p><strong>Time Left:</strong> <span id="timeLeftValue"></span></p>
            <p><strong>Cosmic Energy (Moves):</strong> <span id="cosmicEnergyValue"></span></p>
            <p><strong>Galaxies Formed:</strong> <span id="galaxiesFormedCount">0</span> / <span id="targetGalaxiesNeeded"></span></p>
            <p><strong>Particles:</strong> <span id="particleCount"></span></p>
            <p><strong>Attractors:</strong> <span id="numGalaxiesValue"></span></p>
            <p><strong>Entropy:</strong> <span id="entropyValue"></span></p>
            <p><strong>Next Cosmic Event In:</strong> <span id="cosmicEventCountdownValue"></span>s</p>
            <p><strong>Last Cosmic Event:</strong> <span id="lastCosmicEventValue">None</span></p>
            <p><strong>Particles Obliterated:</strong> <span id="suckedParticleCount">0</span></p>
        </div>
    </div>

    <div id="gameControls" class="control-panel">
        <button id="placeGalaxyBtn" class="game-button">Place Attractor</button>
        <button id="removeGalaxyBtn" class="game-button">Remove Attractor</button>
    </div>

    <div id="canvas-container" class="w-full h-screen relative"></div>

    <div id="messageScreen" class="game-message">
        <p id="messageText"></p>
        <button id="restartGameBtn" class="game-button mt-4">Play Again</button>
    </div>

    <script>
        // Global variables for Three.js scene
        let scene, camera, renderer, controls;
        let particles; // Particle system
        let expansionSpeed = 0.05; // Controls how fast particles move outwards
        const numParticles = 50000; // Number of particles in the simulation

        // Game State Variables
        let isGameActive = false;
        let isBigCrunchActive = false; // Flag for Big Crunch event
        let timeLeft = 180; // 3 minutes for the game (seconds)
        let gameTimerInterval;
        let entropyTimerInterval; // Timer for entropy updates

        let cosmicEnergy = 10; // Player's moves
        let energyRegenTimer;

        let galaxiesFormedCount = 0;
        let targetGalaxiesNeeded = 10; // Number of galaxies to form to win

        let gameMode = 'play'; // 'play', 'place', 'remove'

        // Galaxy Formation Parameters
        const galaxyFormationRadius = 20; // Radius around a proto-galaxy to count particles for formation
        const minParticlesForGalaxy = 750; // Number of particles needed to form a galaxy

        // Gravity parameters (from original simulator)
        const gravitationalConstant = 0.01;
        const softeningFactor = 5.0;

        // Speed of light constant (from original simulator)
        const speedOfLight = 2.0;

        // Galaxy clumping parameters (from original simulator)
        let numProtoGalaxies = 0; // Start with 0, player places them
        const protoGalaxyInitialSpread = 30; // Still used for initial random velocity boundaries
        const protoGalaxies = []; // Array to store the THREE.Group objects for proto-galaxies (each group holds a cross)
        const minGalaxyMass = 50;
        const maxGalaxyMassRand = 25;

        // Dynamic galaxy management parameters (for cosmic events)
        const minActiveGalaxies = 3; // Minimum number of proto-galaxies to keep active for events
        const maxActiveGalaxies = 16; // Maximum number of proto-galaxies allowed for events

        // Removal Ejection parameters (from original simulator)
        const removalEjectionRadius = 40;
        const removalForceMultiplier = 0.75;

        // Cosmic Event Parameters
        let cosmicEventInterval;
        let cosmicEventCountdown = 0; // Countdown for next event
        let cosmicEventTimer; // Timer for cosmic events

        // Black Hole Parameters
        const blackHoleSize = 5; // Visual size of the black hole
        const blackHoleSuckRadius = 15; // Radius within which particles are sucked
        const blackHoleDuration = 10; // How long a black hole stays active (seconds)
        const maxBlackHoles = 3; // Limit the number of active black holes
        const blackHoleMass = 1000; // Mass of the black hole
        const blackHoles = []; // Array to store active black hole objects
        let suckedParticleCount = 0; // Counter for particles sucked by black holes

        // Raycaster for click interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // --- UI Elements ---
        const messageScreen = document.getElementById('messageScreen');
        const messageText = document.getElementById('messageText');
        const restartGameBtn = document.getElementById('restartGameBtn');
        const placeGalaxyBtn = document.getElementById('placeGalaxyBtn');
        const removeGalaxyBtn = document.getElementById('removeGalaxyBtn');
        const canvasContainer = document.getElementById('canvas-container');
        const lastCosmicEventValue = document.getElementById('lastCosmicEventValue');
        const suckedParticleCountElement = document.getElementById('suckedParticleCount');
        const particleCountElement = document.getElementById('particleCount');
        const gameControls = document.getElementById('gameControls'); // Get game controls div
        const entropyValueElement = document.getElementById('entropyValue'); // Entropy display element

        // Audio elements
        const backgroundMusic = document.getElementById('backgroundMusic');
        const volumeSlider = document.getElementById('volumeSlider');

        // --- Game Functions ---

        function startGame() {
            messageScreen.style.display = 'none';
            gameControls.style.display = 'flex'; // Ensure controls are visible

            // Attempt to play background music (will likely require user interaction)
            backgroundMusic.play().catch(error => {
                console.log("Autoplay prevented:", error);
                // Inform user to click somewhere to enable audio, if needed
            });

            // Re-initialize everything for a fresh game
            initThreeJSScene();
            createParticles();

            // Clear existing galaxies
            protoGalaxies.forEach(galaxy => scene.remove(galaxy));
            protoGalaxies.length = 0;

            // Clear existing black holes
            blackHoles.forEach(bh => scene.remove(bh.mesh));
            blackHoles.length = 0;
            suckedParticleCount = 0;

            // Reset game state variables
            isGameActive = true;
            isBigCrunchActive = false; // Reset big crunch flag
            timeLeft = 180;
            cosmicEnergy = 10; // Initial finite moves
            galaxiesFormedCount = 0;
            gameMode = 'play';
            cosmicEventCountdown = getRandomCosmicEventInterval();
            lastCosmicEventValue.textContent = "None";

            // Update UI
            document.getElementById('timeLeftValue').textContent = timeLeft;
            document.getElementById('cosmicEnergyValue').textContent = cosmicEnergy;
            document.getElementById('galaxiesFormedCount').textContent = galaxiesFormedCount;
            document.getElementById('targetGalaxiesNeeded').textContent = targetGalaxiesNeeded;
            particleCountElement.textContent = numParticles - suckedParticleCount;
            document.getElementById('numGalaxiesValue').textContent = protoGalaxies.length;
            document.getElementById('cosmicEventCountdownValue').textContent = cosmicEventCountdown;
            suckedParticleCountElement.textContent = suckedParticleCount;
            entropyValueElement.textContent = "Calculating..."; // Initial entropy text


            // Start timers/intervals
            if (gameTimerInterval) clearInterval(gameTimerInterval);
            gameTimerInterval = setInterval(updateGameTimer, 1000);

            if (energyRegenTimer) clearInterval(energyRegenTimer);

            if (cosmicEventTimer) clearInterval(cosmicEventTimer);
            cosmicEventTimer = setInterval(updateCosmicEventCountdown, 1000);

            if (entropyTimerInterval) clearInterval(entropyTimerInterval); // Clear any existing entropy timer
            entropyTimerInterval = setInterval(updateEntropyDisplay, 1000); // Start entropy timer

            // Ensure controls are enabled for orbiting
            controls.enabled = true;

            // Reset button states
            resetButtonStates();
            
            // Start animation loop if not already running
            if (!animationFrameId) {
                animate();
            }
        }

        function updateGameTimer() {
            if (!isGameActive) return;
            timeLeft--;
            document.getElementById('timeLeftValue').textContent = timeLeft;
            if (timeLeft <= 0) {
                triggerBigCrunch(); // Trigger Big Crunch
            }
        }

        function triggerBigCrunch() {
            isGameActive = false; // Stop all regular game logic
            isBigCrunchActive = true; // Activate Big Crunch mode
            clearInterval(gameTimerInterval);
            clearInterval(cosmicEventTimer);
            clearInterval(entropyTimerInterval); // Clear entropy timer during crunch
            gameControls.style.display = 'none'; // Hide controls during crunch
            messageScreen.style.display = 'flex'; // Show message screen
            messageText.textContent = "OUT OF TIME";
            restartGameBtn.style.display = 'none'; // Hide play again button temporarily

            // Remove all existing proto-galaxies and black holes from the scene
            protoGalaxies.forEach(galaxy => scene.remove(galaxy));
            protoGalaxies.length = 0; // Clear array
            blackHoles.forEach(bh => scene.remove(bh.mesh));
            blackHoles.length = 0; // Clear array

            // Set up a final delay before showing game over message
            setTimeout(() => {
                isBigCrunchActive = false; // Deactivate crunch mode
                endGame(false); // Now officially end the game and show restart button
            }, 10000); // 10 seconds for the crunch effect
        }

        function getRandomCosmicEventInterval() {
            return Math.floor(Math.random() * (25 - 15 + 1)) + 15;
        }

        function updateCosmicEventCountdown() {
            if (!isGameActive) return;
            cosmicEventCountdown--;
            document.getElementById('cosmicEventCountdownValue').textContent = cosmicEventCountdown;
            if (cosmicEventCountdown <= 0) {
                triggerCosmicEvent();
                cosmicEventCountdown = getRandomCosmicEventInterval();
            }
        }

        function triggerCosmicEvent() {
            const eventTypeRoll = Math.random();
            let action;

            if (eventTypeRoll < 0.4) {
                action = 'add';
            } else if (eventTypeRoll < 0.8) {
                action = 'remove';
            } else {
                action = 'blackhole';
            }

            const eventPosition = new THREE.Vector3(
                (Math.random() - 0.5) * protoGalaxyInitialSpread * 4,
                (Math.random() - 0.5) * protoGalaxyInitialSpread * 4,
                (Math.random() - 0.5) * protoGalaxyInitialSpread * 4
            );

            if (action === 'add' && protoGalaxies.length < maxActiveGalaxies) {
                // Use the new function for placing at a specific position
                placeProtoGalaxyAtPosition(eventPosition, true); // true indicates it's an event-spawned galaxy
                lastCosmicEventValue.textContent = "New Attractor Appeared!";

            } else if (action === 'remove' && protoGalaxies.length > minActiveGalaxies) {
                const randomIndex = Math.floor(Math.random() * protoGalaxies.length);
                const galaxyToRemove = protoGalaxies[randomIndex];

                // Use the new function for removing a specific galaxy
                removeSpecificProtoGalaxy(galaxyToRemove, true); // true indicates it's an event-removed galaxy
                lastCosmicEventValue.textContent = "A Galaxy Vanished!";
                cosmicEnergy++; // Grant cosmic energy for removed galaxy
                document.getElementById('cosmicEnergyValue').textContent = cosmicEnergy;

            } else if (action === 'blackhole' && blackHoles.length < maxBlackHoles) {
                const blackHoleMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.8 });
                const blackHoleGeometry = new THREE.SphereGeometry(blackHoleSize, 16, 16);
                const blackHoleMesh = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
                blackHoleMesh.position.copy(eventPosition);
                scene.add(blackHoleMesh);

                blackHoles.push({
                    mesh: blackHoleMesh,
                    spawnTime: Date.now(),
                    suckRadius: blackHoleSuckRadius,
                    mass: blackHoleMass
                });
                lastCosmicEventValue.textContent = "A Black Hole Formed!";
                console.log("Cosmic Event: Black hole formed!");
            } else {
                lastCosmicEventValue.textContent = "Cosmic Fluctuation";
            }
        }

        /**
         * Places a new proto-galaxy at a specified 3D position.
         * @param {THREE.Vector3} position The 3D coordinates where the galaxy will be placed.
         * @param {boolean} isEventSpawned True if this galaxy is spawned by a cosmic event, false otherwise.
         */
        function placeProtoGalaxyAtPosition(position, isEventSpawned = false) {
            const crossMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const protoGalaxyGroup = new THREE.Group();

            const galaxyMass = minGalaxyMass + Math.random() * maxGalaxyMassRand;
            protoGalaxyGroup.mass = galaxyMass;
            protoGalaxyGroup.isFormed = false;

            const sizeScale = galaxyMass / (minGalaxyMass + maxGalaxyMassRand);
            const crossArmLength = 2 * sizeScale;
            const crossArmThickness = 0.2 * sizeScale;

            const horizontalArm = new THREE.Mesh(
                new THREE.BoxGeometry(crossArmLength, crossArmThickness, crossArmThickness),
                crossMaterial
            );
            protoGalaxyGroup.add(horizontalArm);

            const verticalArm = new THREE.Mesh(
                new THREE.BoxGeometry(crossArmThickness, crossArmLength, crossArmThickness),
                crossMaterial
            );
            protoGalaxyGroup.add(verticalArm);

            const depthArm = new THREE.Mesh(
                new THREE.BoxGeometry(crossArmThickness, crossArmThickness, crossArmLength),
                crossMaterial
            );
            protoGalaxyGroup.add(depthArm);

            protoGalaxyGroup.position.copy(position); // Use the provided position
            protoGalaxyGroup.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.02,
                (Math.random() - 0.5) * 0.02,
                (Math.random() - 0.5) * 0.02
            );

            scene.add(protoGalaxyGroup);
            protoGalaxies.push(protoGalaxyGroup);
            document.getElementById('numGalaxiesValue').textContent = protoGalaxies.length;

            // Only hide message if it's a player action, not an event
            if (!isEventSpawned) {
                // messageScreen.style.display = 'none'; // Removed as per user request
            }
        }

        /**
         * Removes a specific proto-galaxy from the simulation and applies an ejection force to nearby particles.
         * @param {THREE.Group} galaxyToRemove The THREE.Group object representing the galaxy to remove.
         * @param {boolean} isEventRemoved True if this galaxy is removed by a cosmic event, false otherwise.
         */
        function removeSpecificProtoGalaxy(galaxyToRemove, isEventRemoved = false) {
            if (!isGameActive) return;
            if (!galaxyToRemove) {
                console.log("No galaxy object provided for removal.");
                return;
            }

            // If removing a formed galaxy, decrement the count
            if (galaxyToRemove.isFormed) {
                galaxiesFormedCount--;
                document.getElementById('galaxiesFormedCount').textContent = galaxiesFormedCount;
            }

            const galaxyPosition = galaxyToRemove.position.clone();
            const galaxyMass = galaxyToRemove.mass;

            scene.remove(galaxyToRemove);
            // Remove from the array
            const index = protoGalaxies.indexOf(galaxyToRemove);
            if (index > -1) {
                protoGalaxies.splice(index, 1);
            }
            document.getElementById('numGalaxiesValue').textContent = protoGalaxies.length;

            const positions = particles.geometry.attributes.position.array;
            const velocities = particles.geometry.attributes.velocity.array;

            for (let i = 0; i < numParticles; i++) {
                const i3 = i * 3;
                const particlePos = new THREE.Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]);

                const dx = particlePos.x - galaxyPosition.x;
                const dy = particlePos.y - galaxyPosition.y;
                const dz = particlePos.z - galaxyPosition.z;
                const distanceSq = dx * dx + dy * dy + dz * dz;
                const distance = Math.sqrt(distanceSq);

                if (distance < removalEjectionRadius && distance > 0) {
                    const effectiveDistanceSq = distanceSq + softeningFactor;
                    const forceMagnitude = (gravitationalConstant * removalForceMultiplier * galaxyMass) / effectiveDistanceSq;

                    const ejectionDirectionX = dx / distance;
                    const ejectionDirectionY = dy / distance;
                    const ejectionDirectionZ = dz / distance;

                    velocities[i3] += ejectionDirectionX * forceMagnitude;
                    velocities[i3 + 1] += ejectionDirectionY * forceMagnitude;
                    velocities[i3 + 2] += ejectionDirectionZ * forceMagnitude;

                    const currentVelocityMagnitude = Math.sqrt(
                        velocities[i3] * velocities[i3] +
                        velocities[i3 + 1] * velocities[i3 + 1] +
                        velocities[i3 + 2] * velocities[i3 + 2]
                    );
                    if (currentVelocityMagnitude > speedOfLight) {
                        const scaleFactor = speedOfLight / currentVelocityMagnitude;
                        velocities[i3] *= scaleFactor;
                        velocities[i3 + 1] *= scaleFactor;
                        velocities[i3 + 2] *= scaleFactor;
                    }
                }
            }
            particles.geometry.attributes.velocity.needsUpdate = true;

            // Only hide message if it's a player action, not an event
            if (!isEventRemoved) {
                // messageScreen.style.display = 'none'; // Removed as per user request
            }
        }

        // Function to measure entropy based on particle distribution
        function measureEntropy() {
            if (!particles || !particles.geometry || !particles.geometry.attributes.position || !particles.geometry.attributes.sucked) {
                return 0; // Return 0 or handle initial state where particles might not be ready
            }
            const positions = particles.geometry.attributes.position.array;
            const suckedParticles = particles.geometry.attributes.sucked.array;

            let totalSquaredDistance = 0;
            let activeParticleCount = 0;
            const origin = new THREE.Vector3(0, 0, 0); // Center of the system

            for (let i = 0; i < numParticles; i++) {
                if (!suckedParticles[i]) { // Only consider active, non-sucked particles
                    const i3 = i * 3;
                    const x = positions[i3];
                    const y = positions[i3 + 1];
                    const z = positions[i3 + 2];
                    totalSquaredDistance += (x * x + y * y + z * z); // Squared distance from origin
                    activeParticleCount++;
                }
            }

            if (activeParticleCount === 0) {
                return 0; // If no active particles, entropy is considered 0 (all ordered to center or removed)
            }

            return totalSquaredDistance / activeParticleCount; // Average squared distance
        }

        // Function to update the entropy display in the UI
        function updateEntropyDisplay() {
            // Only update if the game is active or if big crunch is ongoing
            if (isGameActive || isBigCrunchActive) {
                entropyValueElement.textContent = measureEntropy().toFixed(0); // Display with 2 decimal places
            }
        }

        function checkGalaxyFormation() {
            const positions = particles.geometry.attributes.position.array;
            let currentFormedCount = 0;

            protoGalaxies.forEach(galaxy => {
                let particlesInInfluence = 0; // Reset for each galaxy
                for (let i = 0; i < numParticles; i++) {
                    const i3 = i * 3;
                    if (particles.geometry.attributes.sucked && particles.geometry.attributes.sucked.array[i]) {
                        continue;
                    }
                    const particlePos = new THREE.Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]);
                    if (particlePos.distanceTo(galaxy.position) < galaxyFormationRadius) {
                        particlesInInfluence++;
                    }
                }

                if (particlesInInfluence >= minParticlesForGalaxy) {
                    if (!galaxy.isFormed) {
                        galaxy.isFormed = true;
                        galaxy.children.forEach(mesh => {
                            if (mesh.material) {
                                mesh.material.color.set(0x00ff00);
                            }
                        });
                    }
                    currentFormedCount++;
                } else {
                    if (galaxy.isFormed) {
                        galaxy.isFormed = false;
                        galaxy.children.forEach(mesh => {
                            if (mesh.material) {
                                mesh.material.color.set(0xffff00);
                            }
                        });
                    }
                }
            });

            if (currentFormedCount !== galaxiesFormedCount) {
                galaxiesFormedCount = currentFormedCount;
                document.getElementById('galaxiesFormedCount').textContent = galaxiesFormedCount;
            }

            if (galaxiesFormedCount >= targetGalaxiesNeeded) {
                endGame(true);
            }
        }

        function endGame(isWin) {
            isGameActive = false;
            clearInterval(gameTimerInterval);
            clearInterval(cosmicEventTimer);
            clearInterval(entropyTimerInterval); // Clear entropy timer on game end

            if (isWin) {
                messageText.textContent = `You Win! Formed ${galaxiesFormedCount} Galaxies!`;
            } else {
                messageText.textContent = `You formed ${galaxiesFormedCount} of ${targetGalaxiesNeeded} galaxies.`;
            }
            messageScreen.style.display = 'flex';
            restartGameBtn.style.display = 'inline-block'; // Show play again button
            // resetButtonStates(); // Reset button states after action
        }

        // --- Three.js Initialization ---

        let animationFrameId;

        function initThreeJSScene() {
            if (scene) {
                // Dispose of old objects if restarting
                scene.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                    scene.remove(child);
                });
            }

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 100;

            if (renderer) {
                renderer.setSize(window.innerWidth, window.innerHeight);
            } else {
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                canvasContainer.appendChild(renderer.domElement);
            }

            if (typeof THREE.OrbitControls === 'function') {
                if (controls) {
                    controls.dispose();
                }
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.screenSpacePanning = false;
                controls.maxDistance = 500;
                controls.minDistance = 10;
                controls.enabled = true;
            } else {
                console.error("THREE.OrbitControls is not a constructor. Camera controls will not be available.");
                controls = null;
            }
        }

        function createParticles() {
            if (particles) {
                particles.geometry.dispose();
                particles.material.dispose();
                scene.remove(particles);
            }

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(numParticles * 3);
            const velocities = new Float32Array(numParticles * 3);
            const colors = new Float32Array(numParticles * 3);
            const sucked = new Uint8Array(numParticles);

            const singularityRadius = 0.01;

            for (let i = 0; i < numParticles; i++) {
                const i3 = i * 3;

                positions[i3] = (Math.random() - 0.5) * singularityRadius;
                positions[i3 + 1] = (Math.random() - 0.5) * singularityRadius;
                positions[i3 + 2] = (Math.random() - 0.5) * singularityRadius;

                const direction = new THREE.Vector3(
                    Math.random() - 0.5,
                    Math.random() - 0.5,
                    Math.random() - 0.5
                ).normalize();

                const initialSpeed = Math.min(Math.random() * 0.5 + 0.1, speedOfLight);

                velocities[i3] = direction.x * initialSpeed;
                velocities[i3 + 1] = direction.y * initialSpeed;
                velocities[i3 + 2] = direction.z * initialSpeed;

                colors[i3] = Math.random();
                colors[i3 + 1] = Math.random();
                colors[i3 + 2] = Math.random();

                sucked[i] = 0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('sucked', new THREE.BufferAttribute(sucked, 1));

            const material = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- Interaction Logic ---
        function onCanvasClick(event) {
            if (!isGameActive) return; // Only allow clicks if game is active

            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update the raycaster with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            if (gameMode === 'place') {
                if (cosmicEnergy > 0) {
                    // Project a point some distance in front of the camera along the ray
                    // This creates a point in 3D space where the user clicked.
                    const clickPosition = new THREE.Vector3();
                    // Project at a distance from camera, roughly in the center of the simulation space
                    raycaster.ray.at(camera.position.length(), clickPosition);

                    placeProtoGalaxyAtPosition(clickPosition);
                    cosmicEnergy--;
                    document.getElementById('cosmicEnergyValue').textContent = cosmicEnergy;
                    messageScreen.style.display = 'none'; // Hide message after placement
                } else {
                    // messageText.textContent = "Not enough Cosmic Energy to place an attractor!"; // Removed as per user request
                    messageScreen.style.display = 'none'; // Hide message as per user request
                    restartGameBtn.style.display = 'inline-block'; // Show restart button
                }
                gameMode = 'play';
                controls.enabled = true; // Re-enable orbit controls
                resetButtonStates(); // Reset button states after action
            } else if (gameMode === 'remove') {
                if (protoGalaxies.length > 0) {
                    // Find the closest galaxy to the ray
                    let closestGalaxy = null;
                    let minDistance = Infinity;
                    const intersectionThreshold = 5; // How close the ray needs to be to a galaxy to select it

                    protoGalaxies.forEach(galaxy => {
                        const distance = raycaster.ray.distanceToPoint(galaxy.position);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestGalaxy = galaxy;
                        }
                    });

                    if (closestGalaxy && minDistance < intersectionThreshold) {
                        removeSpecificProtoGalaxy(closestGalaxy);
                        cosmicEnergy++; // Refund energy for removing
                        document.getElementById('cosmicEnergyValue').textContent = cosmicEnergy;
                        messageScreen.style.display = 'none'; // Hide message after removal
                    } else {
                        // messageText.textContent = "No attractor found close enough to the clicked point. Try again!"; // Removed as per user request
                        messageScreen.style.display = 'none'; // Hide message as per user request
                        restartGameBtn.style.display = 'none'; // Keep restart button hidden
                    }
                } else {
                    // messageText.textContent = "No attractors to remove!"; // Removed as per user request
                    messageScreen.style.display = 'none'; // Hide message as per user request
                    restartGameBtn.style.display = 'inline-block'; // Show restart button
                }
                gameMode = 'play';
                controls.enabled = true; // Re-enable orbit controls
                resetButtonStates(); // Reset button states after action
            } else { // gameMode === 'play'
                // If in play mode, just ensure controls are enabled (already done by the event listener setup)
                controls.enabled = true;
            }
        }

        // Function to reset button text and color to default
        function resetButtonStates() {
            placeGalaxyBtn.textContent = "Place Attractor";
            placeGalaxyBtn.classList.remove('active-place');
            removeGalaxyBtn.textContent = "Remove Attractor";
            removeGalaxyBtn.classList.remove('active-remove');
            messageScreen.style.display = 'none'; // Ensure message screen is hidden
            restartGameBtn.style.display = 'inline-block'; // Ensure restart button is visible if game is over
        }


        // Animation loop
        function animate() {
            animationFrameId = requestAnimationFrame(animate);

            if (controls) {
                controls.update(); // Always update controls for camera movement
            }
            renderer.render(scene, camera); // Always render

            // --- Big Crunch Logic (Overrides normal game physics) ---
            if (isBigCrunchActive) {
                const crunchCenter = new THREE.Vector3(0, 0, 0);
                const crunchForceMagnitude = 200.0; // Increased significantly for dramatic effect
                const crunchParticleThreshold = 10; // Smaller threshold for hiding particles

                const positions = particles.geometry.attributes.position.array;
                const velocities = particles.geometry.attributes.velocity.array;
                const colors = particles.geometry.attributes.color.array;
                const suckedParticles = particles.geometry.attributes.sucked.array;

                for (let i = 0; i < numParticles; i++) {
                    const i3 = i * 3;

                    if (suckedParticles[i]) continue; // Skip particles already sucked

                    const currentX = positions[i3];
                    const currentY = positions[i3 + 1];
                    const currentZ = positions[i3 + 2];

                    const dx = crunchCenter.x - currentX;
                    const dy = crunchCenter.y - currentY;
                    const dz = crunchCenter.z - currentZ;
                    const distanceSq = dx * dx + dy * dy + dz * dz;
                    const distance = Math.sqrt(distanceSq);

                    if (distance < crunchParticleThreshold) {
                        // Particle has effectively crunched, hide it
                        suckedParticles[i] = 1;
                        positions[i3] = 100000; // Move far away
                        positions[i3 + 1] = 100000;
                        positions[i3 + 2] = 100000;
                        colors[i3] = 0; colors[i3+1] = 0; colors[i3+2] = 0; // Make it black/invisible
                        continue;
                    }

                    const effectiveDistanceSq = distanceSq + softeningFactor; // Still use softening factor
                    const forceMagnitude = (gravitationalConstant * crunchForceMagnitude) / effectiveDistanceSq;

                    const directionX = dx / distance;
                    const directionY = dy / distance;
                    const directionZ = dz / distance;

                    velocities[i3] += directionX * forceMagnitude;
                    velocities[i3 + 1] += directionY * forceMagnitude;
                    velocities[i3 + 2] += directionZ * forceMagnitude;

                    // Cap velocity, but allow faster than normal game play for crunch
                    const currentVelocityMagnitude = Math.sqrt(
                        velocities[i3] * velocities[i3] +
                        velocities[i3 + 1] * velocities[i3 + 1] +
                        velocities[i3 + 2] * velocities[i3 + 2]
                    );
                    const crunchSpeedCap = speedOfLight * 20; // Allow particles to move much faster
                    if (currentVelocityMagnitude > crunchSpeedCap) {
                        const scaleFactor = crunchSpeedCap / currentVelocityMagnitude;
                        velocities[i3] *= scaleFactor;
                        velocities[i3 + 1] *= scaleFactor;
                        velocities[i3 + 2] *= scaleFactor;
                    }

                    positions[i3] += velocities[i3] * 1.0; // Use a fixed step size for crunch
                    positions[i3 + 1] += velocities[i3 + 1] * 1.0;
                    positions[i3 + 2] += velocities[i3 + 2] * 1.0;
                }
                particles.geometry.attributes.position.needsUpdate = true;
                particles.geometry.attributes.sucked.needsUpdate = true;
                particles.geometry.attributes.color.needsUpdate = true;

                return; // Skip the rest of the game physics during big crunch
            }

            // --- Normal game physics (only runs if not isBigCrunchActive and game is active) ---
            if (!isGameActive) return; // If game is over but not in crunch, just render and return

            const positions = particles.geometry.attributes.position.array;
            const velocities = particles.geometry.attributes.velocity.array;
            const colors = particles.geometry.attributes.color.array;
            const suckedParticles = particles.geometry.attributes.sucked.array;

            // Existing proto-galaxy movement
            protoGalaxies.forEach(galaxy => {
                galaxy.position.x += galaxy.velocity.x;
                galaxy.position.y += galaxy.velocity.y;
                galaxy.position.z += galaxy.velocity.z;

                if (Math.abs(galaxy.position.x) > protoGalaxyInitialSpread * 4) galaxy.velocity.x *= -1;
                if (Math.abs(galaxy.position.y) > protoGalaxyInitialSpread * 4) galaxy.velocity.y *= -1;
                if (Math.abs(galaxy.position.z) > protoGalaxyInitialSpread * 4) galaxy.velocity.z *= -1;
            });

            // Existing black hole physics (sucking particles)
            const currentTime = Date.now();
            for (let i = blackHoles.length - 1; i >= 0; i--) {
                const bh = blackHoles[i];
                if ((currentTime - bh.spawnTime) / 1000 > blackHoleDuration) {
                    scene.remove(bh.mesh);
                    blackHoles.splice(i, 1);
                    console.log("Black hole expired and removed.");
                    continue;
                }

                for (let j = 0; j < numParticles; j++) {
                    const j3 = j * 3;
                    if (suckedParticles[j]) continue;

                    const particlePos = new THREE.Vector3(positions[j3], positions[j3 + 1], positions[j3 + 2]);
                    const distance = particlePos.distanceTo(bh.mesh.position);

                    const dx = bh.mesh.position.x - particlePos.x;
                    const dy = bh.mesh.position.y - particlePos.y;
                    const dz = bh.mesh.position.z - particlePos.z;
                    const distanceToBhSq = dx * dx + dy * dy + dz * dz;
                    const distanceToBh = Math.sqrt(distanceToBhSq);

                    if (distanceToBh > 0) {
                        const effectiveDistanceToBhSq = distanceToBhSq + softeningFactor;
                        const forceMagnitudeBh = (gravitationalConstant * bh.mass) / effectiveDistanceToBhSq;

                        const directionXBh = dx / distanceToBh;
                        const directionYBh = dy / distanceToBh;
                        const directionZBh = dz / distanceToBh;

                        velocities[j3] += directionXBh * forceMagnitudeBh;
                        velocities[j3 + 1] += directionYBh * forceMagnitudeBh;
                        velocities[j3 + 2] += directionZBh * forceMagnitudeBh;
                    }


                    if (distance < bh.suckRadius) {
                        suckedParticles[j] = 1;
                        suckedParticleCount++;
                        suckedParticleCountElement.textContent = suckedParticleCount;
                        particleCountElement.textContent = numParticles - suckedParticleCount;

                        positions[j3] = 100000;
                        positions[j3 + 1] = 100000;
                        positions[j3 + 2] = 100000;
                        colors[j3] = 0; colors[j3+1] = 0; colors[j3+2] = 0;
                    }
                }
            }
            particles.geometry.attributes.sucked.needsUpdate = true;
            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;


            for (let i = 0; i < numParticles; i++) {
                const i3 = i * 3;

                if (suckedParticles[i]) continue;

                const currentX = positions[i3];
                const currentY = positions[i3 + 1];
                const currentZ = positions[i3 + 2];

                let minDistanceSq = Infinity;
                let closestGravitySource = null;

                for (let j = 0; j < protoGalaxies.length; j++) {
                    const galaxy = protoGalaxies[j];
                    const dx = galaxy.position.x - currentX;
                    const dy = galaxy.position.y - currentY;
                    const dz = galaxy.position.z - currentZ;
                    const distanceSq = dx * dx + dy * dy + dz * dz;

                    if (distanceSq < minDistanceSq) {
                        minDistanceSq = distanceSq;
                        closestGravitySource = galaxy;
                    }
                }

                if (closestGravitySource) {
                    const distance = Math.sqrt(minDistanceSq);

                    const effectiveDistanceSq = minDistanceSq + softeningFactor;
                    const forceMagnitude = (gravitationalConstant * closestGravitySource.mass) / effectiveDistanceSq;

                    const directionX = (closestGravitySource.position.x - currentX) / distance;
                    const directionY = (closestGravitySource.position.y - currentY) / distance;
                    const directionZ = (closestGravitySource.position.z - currentZ) / distance;

                    velocities[i3] += directionX * forceMagnitude;
                    velocities[i3 + 1] += directionY * forceMagnitude;
                    velocities[i3 + 2] += directionZ * forceMagnitude;
                }

                const currentVelocityMagnitude = Math.sqrt(
                    velocities[i3] * velocities[i3] +
                    velocities[i3 + 1] * velocities[i3 + 1] +
                    velocities[i3 + 2] * velocities[i3 + 2]
                );

                if (currentVelocityMagnitude > speedOfLight) {
                    const scaleFactor = speedOfLight / currentVelocityMagnitude;
                    velocities[i3] *= scaleFactor;
                    velocities[i3 + 1] *= scaleFactor;
                    velocities[i3 + 2] *= scaleFactor;
                }

                positions[i3] += velocities[i3] * expansionSpeed;
                positions[i3 + 1] += velocities[i3 + 1] * expansionSpeed;
                positions[i3 + 2] += velocities[i3 + 2] * expansionSpeed;
            }
            particles.geometry.attributes.position.needsUpdate = true;

            checkGalaxyFormation();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.onload = function() {
            initThreeJSScene();

            // Set initial volume
            backgroundMusic.volume = volumeSlider.value;

            // Event listener for volume slider
            volumeSlider.addEventListener('input', () => {
                backgroundMusic.volume = volumeSlider.value;
            });


            placeGalaxyBtn.addEventListener('click', () => {
                if (isGameActive && cosmicEnergy > 0) {
                    gameMode = 'place';
                    controls.enabled = false; // Disable orbit controls when in placement mode
                    // messageText.textContent = "Click on the simulation to place an attractor."; // Removed
                    messageScreen.style.display = 'none'; // Ensure message is hidden
                    restartGameBtn.style.display = 'none'; // Hide restart button
                    placeGalaxyBtn.textContent = "Place";
                    placeGalaxyBtn.classList.add('active-place');
                    removeGalaxyBtn.textContent = "Remove Attractor"; // Ensure other button is reset
                    removeGalaxyBtn.classList.remove('active-remove'); // Ensure other button is reset
                } else if (isGameActive) {
                    // messageText.textContent = "Not enough Cosmic Energy to place an attractor!"; // Removed
                    messageScreen.style.display = 'none'; // Ensure message is hidden
                    restartGameBtn.style.display = 'inline-block'; // Show restart button
                }
            });

            removeGalaxyBtn.addEventListener('click', () => {
                if (isGameActive && protoGalaxies.length > 0) {
                    gameMode = 'remove';
                    controls.enabled = false; // Disable orbit controls when in removal mode
                    // messageText.textContent = "Click on an attractor to remove it."; // Removed
                    messageScreen.style.display = 'none'; // Ensure message is hidden
                    restartGameBtn.style.display = 'none'; // Hide restart button
                    removeGalaxyBtn.textContent = "Remove";
                    removeGalaxyBtn.classList.add('active-remove');
                    placeGalaxyBtn.textContent = "Place Attractor"; // Ensure other button is reset
                    placeGalaxyBtn.classList.remove('active-place'); // Ensure other button is reset
                } else if (isGameActive) {
                    // messageText.textContent = "No attractors to remove!"; // Removed
                    messageScreen.style.display = 'none'; // Ensure message is hidden
                    restartGameBtn.style.display = 'inline-block'; // Show restart button
                }
            });

            canvasContainer.addEventListener('click', onCanvasClick, false);
            restartGameBtn.addEventListener('click', startGame);

            // Global click listener to ensure music starts if not already playing (due to autoplay restrictions)
            document.addEventListener('click', () => {
                if (backgroundMusic.paused) {
                    backgroundMusic.play().catch(error => {
                        console.log("Playback failed on user click:", error);
                    });
                }
            }, { once: true }); // Only run this once            

            window.addEventListener('resize', onWindowResize, false);

            messageScreen.style.display = 'flex';
            messageText.textContent = "";
            restartGameBtn.textContent = "Start Game";
            gameControls.style.display = 'none'; // Hide controls on initial load
        };
    </script>
</body>
</html>
